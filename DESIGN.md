# CardGame 程序设计文档

## 📋 文档概述

本文档说明 CardGame 项目的技术架构、设计理念和扩展方法。面向开发者提供系统级的设计指导。

## 📚 目录

- [系统架构](#系统架构)
- [设计理念](#设计理念)
- [核心组件](#核心组件)
- [扩展指南](#扩展指南)
- [开发规范](#开发规范)

## 🏗️ 系统架构

### 总体设计

项目采用 **分层MVC架构** + **配置驱动** 的设计模式：

```
┌─────────────────────────────────────────────────────────────┐
│                        应用层                                │
├─────────────────────────────────────────────────────────────┤
│  Controllers (控制层)                                        │
│  • 游戏生命周期管理   • 用户交互处理   • 业务逻辑协调        │
├─────────────────────────────────────────────────────────────┤
│  Views (视图层)                                              │
│  • 界面渲染         • 动画效果       • 用户交互              │
├─────────────────────────────────────────────────────────────┤
│  Models (数据层)                                             │
│  • 游戏状态         • 卡牌数据       • 操作记录              │
├─────────────────────────────────────────────────────────────┤
│  Infrastructure (基础设施层)                                  │
│  • 配置管理         • 撤销管理       • 业务服务              │
└─────────────────────────────────────────────────────────────┘
```

### 数据流向

**初始化流程**: 配置加载 → 数据生成 → 视图创建 → 控制器绑定  
**交互流程**: 用户输入 → 控制器处理 → 模型更新 → 视图刷新  
**撤销流程**: 撤销请求 → 操作回滚 → 状态恢复 → 界面更新

## 💡 设计理念

### 核心原则

1. **单一职责** - 每个组件专注于单一功能
2. **松散耦合** - 组件间通过接口和回调通信
3. **配置驱动** - 游戏内容通过外部配置控制
4. **可扩展性** - 支持新功能的便捷扩展

### 设计模式

- **MVC模式** - 分离数据、视图和控制逻辑
- **命令模式** - 撤销系统的操作封装
- **工厂模式** - 配置驱动的对象创建
- **观察者模式** - 基于回调的事件通知

## 🔧 核心组件

### Models (数据层)

| 组件 | 职责 | 特点 |
|------|------|------|
| `CardModel` | 卡牌属性管理 | 支持序列化，提供匹配逻辑 |
| `GameModel` | 游戏状态管理 | 统一的数据接口，状态同步 |
| `UndoModel` | 操作记录管理 | 命令封装，支持多种操作类型 |

### Views (视图层)

| 组件 | 职责 | 特点 |
|------|------|------|
| `CardView` | 卡牌视觉表现 | 数据绑定，动画效果，交互处理 |
| `GameView` | 界面整体管理 | 布局协调，事件分发，组件管理 |

### Controllers (控制层)

| 组件 | 职责 | 特点 |
|------|------|------|
| `GameController` | 游戏生命周期 | 总体协调，状态管理 |
| `PlayFieldController` | 桌面牌逻辑 | 专门处理桌面区域交互 |
| `StackController` | 手牌堆逻辑 | 专门处理手牌区域交互 |
| `UndoController` | 撤销功能 | 操作回滚，状态恢复 |
| `BaseController` | 通用功能 | 公共方法，减少代码重复 |

### Infrastructure (基础设施)

| 组件 | 职责 | 特点 |
|------|------|------|
| `ConfigManager` | 配置统一管理 | 单例模式，支持热更新 |
| `UndoManager` | 撤销栈管理 | 操作记录，批量回滚 |
| `GameModelFromLevelGenerator` | 数据生成服务 | 配置解析，模型创建 |

## 📈 扩展指南

### 添加新卡牌类型

#### 设计思路
扩展卡牌类型需要从数据模型到视图渲染的全链路修改，遵循"数据→逻辑→视图"的扩展顺序。

#### 扩展步骤

1. **数据模型扩展**
   - 在 `CardModel.h` 中扩展枚举类型（花色、点数）
   - 根据需要添加新的属性字段（特殊能力、效果等）

2. **业务逻辑更新**
   - 在相关 Controller 中添加新卡牌的匹配规则
   - 更新游戏规则判断逻辑

3. **视图渲染适配**
   - 在 `CardView` 中添加新卡牌的渲染逻辑
   - 准备对应的图片资源

4. **配置文件支持**
   - 扩展 JSON 配置格式以支持新卡牌类型
   - 更新配置加载和解析逻辑

5. **测试验证**
   - 创建包含新卡牌的测试关卡
   - 验证渲染效果和游戏逻辑

#### 关键注意事项
- 保持枚举值的向后兼容性
- 新增属性提供合理的默认值
- 确保序列化/反序列化的正确性

### 添加新撤销功能类型

#### 设计思路
撤销系统基于命令模式设计，每种操作对应一个撤销类型。扩展新功能需要定义操作类型、记录必要数据、实现回滚逻辑。

#### 扩展步骤

1. **操作类型定义**
   - 在 `UndoOperationType` 枚举中添加新的操作类型
   - 为新操作类型分配唯一标识

2. **数据结构扩展**
   - 在 `UndoModel` 中添加新操作所需的数据字段
   - 提供对应的访问接口和工厂方法

3. **记录逻辑实现**
   - 在执行操作的 Controller 中添加撤销记录逻辑
   - 确保在操作成功后及时记录撤销信息

4. **回滚逻辑实现**
   - 在 `UndoController` 中添加新操作类型的处理分支
   - 实现具体的状态恢复逻辑

5. **集成测试**
   - 验证操作记录的完整性
   - 测试撤销后的状态正确性

#### 关键注意事项
- 记录操作前的完整状态信息
- 确保撤销操作的原子性
- 考虑多步撤销的一致性

### 通用扩展原则

#### 接口设计
- 新功能优先通过接口扩展而非修改现有代码
- 保持接口的简洁性和一致性
- 提供合理的默认实现

#### 配置驱动
- 新功能尽量通过配置文件控制
- 支持运行时的配置更新
- 保持配置格式的向后兼容

#### 错误处理
- 添加必要的参数验证
- 提供清晰的错误信息
- 确保异常情况下的系统稳定性

## 📋 开发规范

### 代码组织

**目录结构**
```
Classes/
├── models/          # 数据模型，纯数据不依赖视图
├── views/           # 视图组件，负责显示和交互
├── controllers/     # 控制逻辑，协调模型和视图
├── managers/        # 管理器，提供全局服务
├── services/        # 业务服务，处理复杂逻辑
├── configs/         # 配置系统，数据驱动
└── utils/           # 工具函数，独立可复用
```

**文件命名**
- 类名与文件名保持一致
- 每个类对应独立的 .h 和 .cpp 文件
- 按功能模块组织目录结构

### 命名约定

| 类型 | 格式 | 示例 |
|------|------|------|
| 类名 | PascalCase | `CardModel`, `GameController` |
| 函数名 | camelCase | `handleCardClick`, `updateDisplay` |
| 成员变量 | _camelCase | `_cardModel`, `_isInitialized` |
| 常量 | kPascalCase | `kMaxUndoSteps`, `kDefaultFontSize` |
| 枚举值 | UPPER_CASE | `CST_CLUBS`, `CFT_ACE` |

### 设计约束

**依赖关系**
- Models 不依赖 Views 和 Controllers
- Views 可以引用 Models，但不直接修改
- Controllers 协调 Models 和 Views
- Managers 提供服务，不依赖具体业务逻辑

**内存管理**
- 使用智能指针管理对象生命周期
- 避免循环引用导致的内存泄漏
- 及时清理不再使用的资源

**性能考虑**
- 避免频繁的动态内存分配
- 合理使用对象池和缓存机制
- 优化热点代码路径

## 🚀 最佳实践

### 配置管理
- 使用统一的配置接口
- 支持配置的热更新
- 提供配置验证机制

### 错误处理
- 统一的错误码和日志格式
- 优雅的错误恢复机制
- 详细的调试信息输出

### 测试策略
- 为核心组件编写单元测试
- 提供完整的集成测试用例
- 使用自动化测试保证代码质量

### 文档维护
- 保持代码注释的时效性
- 及时更新接口文档
- 记录重要的设计决策

---

本设计文档为 CardGame 项目的技术架构提供了完整的指导原则。遵循这些设计理念和开发规范，可以确保项目的可维护性、可扩展性和代码质量。